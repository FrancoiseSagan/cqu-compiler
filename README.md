## 实验2的一些思路

在开始实验之前，您需要通读IR的定义以及助教的框架代码，例如Operand，Operator，Instruction，CallInst等的定义，并理解符号表的概念。

在生成IR时，我们使用符号表从变量名查找到对应的operand，并且为了处理同名局部变量，这个符号表应该是一个类似栈的结构，在查找时类似LSM的查找一样逆序进行。

接下来我们需要做的就是根据IR和产生式定义完成对所有AST Node的analysis函数，实验的难度较大，大多数corner case都比较难以想到，而实验的测试用例实际上不是特别完整，实验的主要过程就是逐个测试用例调试修改，最终通过所有的测试用例。

### 最简单的IR

从最简单的代码开始，例如

```c
int a = 1;
```

这是一个VarDef节点：

```
VarDef -> Ident {'[' ConstExp ']'} ['=' InitVal]
```

我们需要生成类似这样的一条IR：

```
def a 1
```

问题在于我们如何才能得到这个1，从产生式可以看到InitVal节点和实际的Term节点之间的距离还是很远的。

一种好的做法是让子节点生成暂时性的指令，这里需要使用类似LLVM IR的静态单赋值思想，每次需要生成一条暂时性的指令或者需要得到一个中间结果时使用一个新的t_idx，例如对于这行代码，我们在Number时生成

```
def t1 1
```

这行IR一直向上传递到达VarDef，此时我们已经得知InitVal的最后一条IR的des保存着初始值，只需要生成：

```
def t1 1
def a t1
```

当然这里可通过判断是否为字面量，直接从def的op1提取字面量，生成：

```
def a 1
```

对于其他赋值情况也是如此，对于

```
int a = 1;
int b = 2;
int c = a + b;
```

在分析c的VarDef时，InitVal生成的指令应该为（在IR执行时def和mov区别不大，此处都使用def表示）：

```
def t2 a
def t3 b
add t4 t2 t3
```

只需要生成：

```
def a t4
```
